1
00:00:02,230 --> 00:00:06,540
Knouted abbiamo ottimizzato la nostra piccola applicazione demo qui.

2
00:00:06,910 --> 00:00:16,120
Lasciatemi immergermi nuovamente in quel componente funzionale dello stato Wurzels o componente del contenitore.

3
00:00:16,150 --> 00:00:21,670
Quindi fondamentalmente componenti definiti con CLOS che estendono componenti che sono un modo di creare

4
00:00:21,700 --> 00:00:28,510
un componente e reagire e componenti che sono semplicemente funzioni come tutti gli altri componenti di questa applicazione.

5
00:00:28,960 --> 00:00:36,300
Ora, come ho detto molto in questo corso, dovresti cercare di creare componenti funzionali il pi spesso possibile.

6
00:00:36,360 --> 00:00:37,170
Perch.

7
00:00:38,730 --> 00:00:43,860
Perch questi componenti hanno un focus ristretto e una chiara responsabilit.

8
00:00:43,860 --> 00:00:50,610
correttamente il GSX, ad esempio aggiungendo alcune classi come facciamo qui nel componente cockpit.

9
00:00:50,610 --> 00:00:57,850
Si tratta solo di presentare qualcosa sul rendering di GSX e contengono una logica per visualizzare

10
00:00:57,900 --> 00:00:59,110
Non fanno molto altro.

11
00:00:59,130 --> 00:01:03,980
E una cosa che sicuramente non fanno e che non possono fare  gestire lo stato.

12
00:01:03,990 --> 00:01:09,630
E menziono molto che il motivo per cui abbiamo questa separazione  che vogliamo

13
00:01:09,630 --> 00:01:16,230
avere alcuni punti nella nostra applicazione in cui lo stato dell'applicazione cambia questo fa s che la

14
00:01:16,440 --> 00:01:23,550
tua applicazione rimanga mantenibile anche mentre cresce, pi la tua applicazione cresce pi duramente diventa gestire lo stato

15
00:01:23,610 --> 00:01:31,620
perch se gestisci lo stato in ogni singolo componente  molto difficile tenere traccia di dove hai modificato questo elenco

16
00:01:31,620 --> 00:01:35,040
di persone in cui hai creato questo nuovo post.

17
00:01:35,040 --> 00:01:41,840
Se prendi alcuni contenitori dove lo fai, passa semplicemente allo stato e passa il resto dai

18
00:01:41,850 --> 00:01:42,860
nostri sostegni.

19
00:01:42,870 --> 00:01:48,510
Questo  molto pi facile da gestire perch puoi sempre vedere alla fine che lo stato viene modificato

20
00:01:48,510 --> 00:01:49,590
qui in Aptera come.

21
00:01:49,740 --> 00:01:56,640
E distribuiamo riferimenti alle funzioni che hanno modificato il motivo per cui un oggetto di supporto ma tutti gli

22
00:01:56,940 --> 00:02:00,360
altri componenti non sono in grado di cambiare stato.

23
00:02:00,360 --> 00:02:05,530
Questo  uno dei fondamenti principali di una buona applicazione di re-act.

24
00:02:05,660 --> 00:02:12,800
di classe il meno possibile, ma ovviamente non aver paura di usarli se ha senso.

25
00:02:12,800 --> 00:02:14,030
Usa i componenti

26
00:02:14,210 --> 00:02:20,540
Se si ottiene un punto centrale nella propria applicazione e una buona suddivisione in genere sono pi funzionalit.

27
00:02:20,540 --> 00:02:27,200
Ad esempio, se nella tua app disponi di una caratteristica di blocco e di una funzione di autenticazione,

28
00:02:27,310 --> 00:02:34,760
i componenti di root di queste funzionalit potrebbero essere contenitori che gestiscono lo stato per quell'area caratteristica e lo vedrai

29
00:02:34,760 --> 00:02:39,650
in azione per i punteggi quando ci immergiamo nel progetto di corso pi ampio.

30
00:02:40,160 --> 00:02:47,930
Ma tutti i nostri componenti, come spesso menzionato, dovrebbero essere componenti funzionali, sono anche immersi in una

31
00:02:47,930 --> 00:02:55,700
differenza importante oltre all'esistenza dello stato e nella capacit di metodi che si hanno in componenti basati

32
00:02:55,700 --> 00:02:56,270
sulla classe.

33
00:02:56,270 --> 00:03:01,460
Mi immerger in una importante differenza tra componenti di classe e componenti funzionali nelle

34
00:03:01,460 --> 00:03:02,200
prossime lezioni.

35
00:03:02,390 --> 00:03:07,610
E quello sarebbe il ciclo di vita di un componente prima di immergersi nel ciclo di vita.

36
00:03:07,820 --> 00:03:14,210
Confrontiamo lo stato in meno e lo dichiariamo nuovamente con i componenti completi solo per riportare alla mente i componenti completi

37
00:03:14,210 --> 00:03:14,870
dello stato.

38
00:03:14,870 --> 00:03:19,380
Indicati anche come contenitori e indicano che meno componenti differiscono.

39
00:03:19,430 --> 00:03:24,620
Ma in effetti i componenti completi dello stato sono creati con la parola Klasky ed estendono il

40
00:03:24,620 --> 00:03:29,060
componente mentre lo stato meno quelli sono solo funzioni che ricevono oggetti di scena.

41
00:03:29,120 --> 00:03:32,740
Ora le differenze di importazione sono ovviamente l'accesso allo stato.

42
00:03:32,810 --> 00:03:39,950
E questo nuovo l'esistenza di hook del ciclo di vita in contenitori stateful possiamo accedere allo stato e possiamo implementare

43
00:03:39,950 --> 00:03:46,640
gli hook del ciclo di vita o tornare a quello che  nello stato della lezione successivo l'ultimo componente

44
00:03:46,910 --> 00:03:52,070
non ha mai accesso a uno stato n possono implementare hook del ciclo di vita.

45
00:03:52,250 --> 00:03:58,260
E se vogliamo accedere allo stato e agli oggetti di scena in contenitori completi di stato,

46
00:03:58,610 --> 00:04:09,230
facciamo questo perch aggiungiamo che questa parola chiave questo stato X Y questo puntello x y e in stato ultimo componente lo facciamo noi siamo solo oggetti di scena

47
00:04:09,260 --> 00:04:11,290
x y riceviamo puntelli come argomento.

48
00:04:11,540 --> 00:04:18,410
o gli accessi ai cicli di vita del ciclo di vita usano meno componenti in tutti i casi Aberg.

49
00:04:18,410 --> 00:04:23,860
E come detto spesso usano solo componenti full state se  necessario gestire lo stato

50
00:04:23,870 --> 00:04:31,040
E solo perch non l'abbiamo mai fatto voglio evidenziare questo oggetto x y in stato pieno di componenti.

51
00:04:31,040 --> 00:04:37,520
Se consideriamo il nostro unico componente a pieno stato che abbiamo qui, non utilizza nemmeno oggetti di scena.

52
00:04:37,520 --> 00:04:41,840
Usa solo uno stato ma avrebbe anche accesso agli oggetti di scena.

53
00:04:41,960 --> 00:04:44,130
E posso dimostrartelo.

54
00:04:44,300 --> 00:04:46,840
Lasciami passare alcuni oggetti di scena direttamente dall'indice.

55
00:04:46,880 --> 00:04:47,720
S.

56
00:04:47,870 --> 00:04:58,740
una stringa in cui dir perusi rilevanti Ora questo pu essere il titolo della nostra applicazione in Access che  un contenitore.

57
00:04:58,740 --> 00:05:03,910
Lasciatemi passare un oggetto di titolo qui che pu essere solo

58
00:05:03,960 --> 00:05:09,540
Possiamo ancora accedere al materiale di scena. Non  come se non avesse accesso agli oggetti di scena qui.

59
00:05:09,690 --> 00:05:14,290
Vogliamo forse passare questo alla cabina di pilotaggio per mostrarlo l.

60
00:05:14,580 --> 00:05:20,300
Quindi definiamo un nuovo titolo l una nuova propriet ci pu essere titolo apt.

61
00:05:20,310 --> 00:05:23,220
Non confonderlo con il sostegno che stiamo per trasmettere.

62
00:05:23,550 --> 00:05:25,880
E ora sappiamo che ci sono le scale.

63
00:05:25,980 --> 00:05:33,530
Propriet del titolo una baleniera nel nostro componente dell'app perch l'abbiamo detto qui nell'indice Jaspal.

64
00:05:33,540 --> 00:05:36,440
Ora ovviamente non possiamo accedervi in questo modo.

65
00:05:36,450 --> 00:05:42,230
Non possiamo accedere al titolo dell'elica perch qui la variabile sarebbe una variabile indefinita.

66
00:05:42,240 --> 00:05:44,040
Siamo all'interno del nostro metodo di rendering.

67
00:05:44,160 --> 00:05:49,620
E all'interno di questo metodo non abbiamo mai trovato oggetti di scena e anche questo metodo non riceve l'argomento come

68
00:05:49,920 --> 00:05:51,940
argomento, quindi qui l'oggetto non  definito.

69
00:05:52,470 --> 00:05:57,250
Ma la classe stessa ha la propriet di un prop perch estraiamo il componente.

70
00:05:57,410 --> 00:06:01,800
E proprio come abbiamo accesso a un metodo di stato impostato che non abbiamo mai trovato noi stessi.

71
00:06:02,010 --> 00:06:05,870
Tutti noi abbiamo accesso a una propriet appropriata che non abbiamo mai definito noi stessi.

72
00:06:06,090 --> 00:06:13,500
Ci viene dato e popolato da reagire e quindi possiamo accedere a questi oggetti di scena come questo.

73
00:06:13,800 --> 00:06:15,760
E questo caso lo passiamo semplicemente.

74
00:06:15,780 --> 00:06:18,980
Ma ovviamente potremmo anche stamparlo qui in questo modello.

75
00:06:19,290 --> 00:06:20,950
Ma dal momento che lo trasmettiamo.

76
00:06:21,080 --> 00:06:28,050
Ora vado nella cabina di pilotaggio e gestisco questa nuova propriet, forse qui per mostrarla ai tuoi oggetti

77
00:06:28,360 --> 00:06:36,440
di scena come titolo qui di nuovo solo usando gli oggetti di scena perch riceviamo oggetti di scena come elemento qui.

78
00:06:37,420 --> 00:06:45,160
Con un collega rinforzato, ma gli oggetti di scena come argomento giustificativo che riceviamo per la disfunzione passata automaticamente in esso, reagendo

79
00:06:45,160 --> 00:06:52,630
se salviamo tutti i file ora e torniamo alla nostra applicazione, vedrai rilevanti rispetto a un nuovo titolo che stiamo vedendo

80
00:06:52,630 --> 00:06:58,380
qui perch ora siamo impostando questo nel prossimo file di scacchi e lo passiamo in basso.

81
00:06:58,420 --> 00:07:02,030
E come puoi vedere, otteniamo truppe nella nostra coda di container.

82
00:07:02,140 --> 00:07:05,720
Non l'abbiamo usato prima perch non abbiamo mai ricevuto qualcosa prima.

83
00:07:05,800 --> 00:07:12,520
Ma se vuoi usare gli oggetti di scena, usalo con questi oggetti di scena proprio mentre usi questo stato perch sei in

84
00:07:12,520 --> 00:07:13,510
una classe qui.

85
00:07:13,510 --> 00:07:18,520
Non sei in una funzione che non stai ricevendo oggetti di scena e dichiari come argomenti qui.

