1
00:00:02,230 --> 00:00:07,720
Let's now have a look at the component lifecycle for updating and there we actually have to differentiate

2
00:00:07,720 --> 00:00:09,810
between updates triggered by the parent,

3
00:00:09,940 --> 00:00:14,350
so changing props and internally triggered updates,

4
00:00:14,410 --> 00:00:21,040
so by changing state. Here we'll have the case that the props changed so that the update is triggered

5
00:00:21,040 --> 00:00:22,500
by the parent.

6
00:00:22,600 --> 00:00:28,600
The first method which then gets executed if we implement it is componentWillReceiveProps and we

7
00:00:28,600 --> 00:00:31,070
get the upcoming props as argument here.

8
00:00:31,330 --> 00:00:36,670
Now one thing we can do in this method is we can synchronize our local state of the component if we

9
00:00:36,670 --> 00:00:42,970
have one to the props. So initialize a state with the props so that we then later can change the state

10
00:00:43,060 --> 00:00:49,470
in that component but get the base state depending on the outer props. If you don't need to synchronize

11
00:00:49,470 --> 00:00:49,750
this,

12
00:00:49,750 --> 00:00:52,210
you probably don't need to implement this method.

13
00:00:52,510 --> 00:00:58,360
What you shouldn't do here is cause side effects so don't reach out to the web and fetch data or something

14
00:00:58,360 --> 00:01:04,380
like that because this will lead to a re-rendering of the component and hence to performance issues.

15
00:01:04,510 --> 00:01:06,930
Now ofter WillReceiveProps,

16
00:01:07,030 --> 00:01:10,980
a very interesting method is executed, shouldComponentUpdate

17
00:01:11,290 --> 00:01:13,460
and there we actually get two arguments,

18
00:01:13,630 --> 00:01:16,690
the upcoming props and the upcoming state

19
00:01:16,690 --> 00:01:21,350
so basically the props and state which triggered this update.

20
00:01:21,450 --> 00:01:25,960
This is a method which may actually cancel the updating process,

21
00:01:25,960 --> 00:01:28,510
you can decide if it should or not.

22
00:01:28,510 --> 00:01:32,410
Because if you return true here, the updating continues,

23
00:01:32,590 --> 00:01:37,380
if you return false, the updating stops. In all the other methods,

24
00:01:37,390 --> 00:01:39,040
you never return anything.

25
00:01:39,040 --> 00:01:41,630
But here you can return true or false

26
00:01:41,650 --> 00:01:43,100
and it does have an impact.

27
00:01:43,300 --> 00:01:49,000
If you return false you're basically save performance because react doesn't need to go through the

28
00:01:49,000 --> 00:01:52,060
whole component three and call render and so on

29
00:01:52,270 --> 00:01:57,280
but of course it may also show to your application showing an incorrect state or basically having

30
00:01:57,280 --> 00:01:59,780
an incorrect Dom representation

31
00:01:59,950 --> 00:02:05,180
if you use this in a wrong way. Now we'll have a look at this in the next lectures,

32
00:02:05,200 --> 00:02:11,140
no worries. In the end, what you should do here is decide whether to continue or not, to continue with

33
00:02:11,140 --> 00:02:15,920
the updating I mean but you should as always not cause side effects.

34
00:02:16,910 --> 00:02:22,760
Now let's assume you did allow the updating process to continue, if you didn't, we're done

35
00:02:22,760 --> 00:02:29,600
but if you did allow that, you reach componentWillUpdate, here you also get access to the upcoming props

36
00:02:29,600 --> 00:02:31,260
and upcoming state.

37
00:02:31,400 --> 00:02:36,990
There again you may sync your state to props and you shouldn't cause side effects.

38
00:02:37,100 --> 00:02:42,980
It might be the better place to synchronize your state to props because unlike componentWillReceiveProps,

39
00:02:42,980 --> 00:02:46,850
here you know that you're going to continue with the updating

40
00:02:46,880 --> 00:02:52,890
so you might not spend effort and resources for something which then doesn't matter anyways.

41
00:02:53,420 --> 00:03:00,890
Once this has executed successfully, you reached a render method again, hence rendering the jsx and

42
00:03:00,910 --> 00:03:01,960
telling react

43
00:03:02,210 --> 00:03:06,880
what will actually be the result of your updated component.

44
00:03:07,340 --> 00:03:13,370
And there again as always, you should prepare and structure your jsx code.

45
00:03:13,370 --> 00:03:19,770
Thereafter react will go ahead and update all child components, all child component props to be precise

46
00:03:20,730 --> 00:03:26,040
and that of course may trigger updates for the child components just as it did trigger an update for

47
00:03:26,070 --> 00:03:32,030
this component and then it would call componentDidUpdate at the end.

48
00:03:32,270 --> 00:03:36,620
There you may now cause side effects just like in DidMount,

49
00:03:36,830 --> 00:03:41,100
You mustn't update the state here though because this will trigger a re-render

50
00:03:41,150 --> 00:03:46,520
so it's basically comparable to componentDidMount just for the updating case.

51
00:03:46,520 --> 00:03:52,570
Now let's implement these hooks to see when this get executed and how that behaves.

