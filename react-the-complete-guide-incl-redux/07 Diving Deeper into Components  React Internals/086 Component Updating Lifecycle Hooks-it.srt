1
00:00:02,230 --> 00:00:07,720
Diamo ora un'occhiata al ciclo di vita dei componenti per l'aggiornamento e dobbiamo effettivamente distinguere

2
00:00:07,720 --> 00:00:09,810
tra gli aggiornamenti attivati dal genitore.

3
00:00:09,940 --> 00:00:14,350
Cos cambiando oggetti di scena e aggiornamenti attivati internamente.

4
00:00:14,410 --> 00:00:21,040
Cos cambiando lo stato qui avremo il caso che gli oggetti di scena siano cambiati in modo che l'aggiornamento

5
00:00:21,040 --> 00:00:22,500
sia attivato dal genitore.

6
00:00:22,600 --> 00:00:28,600
Il primo metodo che viene poi eseguito se lo implementiamo come componente riceveranno oggetti di scena e

7
00:00:28,600 --> 00:00:31,070
otteniamo qui gli argomenti di scena imminenti.

8
00:00:31,330 --> 00:00:36,670
lo stato in quel componente, ma ottenere il Baystate dipingere sui puntelli esterni se non  necessario sincronizzarli.

9
00:00:36,670 --> 00:00:42,970
Ora una cosa che potremmo fare in questo metodo  che possiamo sincronizzare il nostro stato locale del componente se ne

10
00:00:43,060 --> 00:00:49,470
abbiamo uno per i prompt in modo da inizializzare uno stato con gli oggetti di scena in modo che in seguito possiamo

11
00:00:49,470 --> 00:00:49,750
cambiare

12
00:00:49,750 --> 00:00:52,210
Probabilmente non  necessario implementare questo metodo.

13
00:00:52,510 --> 00:00:58,360
Quello che non dovresti fare qui  causare effetti collaterali, quindi non raggiungere il Web e recuperare dati o

14
00:00:58,360 --> 00:01:04,380
qualcosa del genere perch ci porter a un rendering reale del componente e quindi a due problemi di prestazioni.

15
00:01:04,510 --> 00:01:06,930
Ora ofter ricever puntelli.

16
00:01:07,030 --> 00:01:10,980
Uno sforzo molto interessante viene eseguito l'aggiornamento dei componenti della camicia.

17
00:01:11,290 --> 00:01:13,460
E qui otteniamo due argomenti.

18
00:01:13,630 --> 00:01:16,690
I prossimi oggetti di scena e il prossimo stato.

19
00:01:16,690 --> 00:01:21,350
Quindi, fondamentalmente, gli oggetti di scena e lo stato che ha attivato questo aggiornamento.

20
00:01:21,450 --> 00:01:25,960
Questo  un metodo che pu effettivamente annullare il processo di aggiornamento.

21
00:01:25,960 --> 00:01:28,510
Puoi decidere se mostrare o meno.

22
00:01:28,510 --> 00:01:32,410
Perch se ritorni vero qui l'aggiornamento continua.

23
00:01:32,590 --> 00:01:37,380
Se si restituisce false, l'aggiornamento si arresta in tutti gli altri metodi.

24
00:01:37,390 --> 00:01:39,040
Non restituisci mai nulla.

25
00:01:39,040 --> 00:01:41,630
Ma qui puoi restituire vero o falso.

26
00:01:41,650 --> 00:01:43,100
Questo ha un impatto.

27
00:01:43,300 --> 00:01:49,000
Se restituisci false, sei fondamentalmente una performance sicura perch re-act non ha bisogno di passare attraverso tutta

28
00:01:49,000 --> 00:01:52,060
la componentry e chiamare il rendering e cos via.

29
00:01:52,270 --> 00:01:57,280
Ma ovviamente questo potrebbe anche mostrare alla tua applicazione che mostra uno stato

30
00:01:57,280 --> 00:01:59,780
errato o fondamentalmente una rappresentazione Dom sbagliata.

31
00:01:59,950 --> 00:02:05,180
Se la usi in modo sbagliato ora daremo un'occhiata a questo nel prossimo decennio.

32
00:02:05,200 --> 00:02:11,140
continuare o meno con l'aggiornamento, voglio dire, ma come sempre non dovresti causare effetti collaterali.

33
00:02:11,140 --> 00:02:15,920
Nessun problema, alla fine, quello che dovresti fare qui  decidere se

34
00:02:16,910 --> 00:02:22,760
Ora supponiamo che tu abbia permesso al processo di aggiornamento di continuare se lo avessi fatto.

35
00:02:22,760 --> 00:02:29,600
Ma se hai permesso che tu raggiunga il componente verr aggiornato qui avrai anche accesso ai prossimi oggetti di

36
00:02:29,600 --> 00:02:31,260
scena e al prossimo stato.

37
00:02:31,400 --> 00:02:36,990
Anche in questo caso potresti sincronizzare il tuo stato con oggetti di scena e non dovresti causare effetti collaterali.

38
00:02:37,100 --> 00:02:42,980
Potrebbe essere un posto migliore per sincronizzare i tuoi stati con gli oggetti di scena, perch a differenza

39
00:02:42,980 --> 00:02:46,850
del componente riceverai oggetti di scena qui saprai che continuerai con l'aggiornamento.

40
00:02:46,880 --> 00:02:52,890
Quindi potresti non spendere sforzi e risorse per qualcosa che poi non importa comunque.

41
00:02:53,420 --> 00:03:00,890
One Steere's  stato eseguito con successo e hai raggiunto un metodo di rendering di nuovo, rendendo quindi il J come

42
00:03:00,910 --> 00:03:01,960
l'assiente che reagisce.

43
00:03:02,210 --> 00:03:06,880
Quale sar effettivamente il risultato del tuo componente aggiornato.

44
00:03:07,340 --> 00:03:13,370
E di nuovo come sempre dovresti preparare e strutturare il tuo codice GSX.

45
00:03:13,370 --> 00:03:19,770
In seguito, re-act andr avanti e aggiorner tutti i componenti del figlio tutti i puntelli dei componenti figlio

46
00:03:20,730 --> 00:03:26,040
per essere precisi e, naturalmente, potrebbe innescare aggiornamenti per i componenti figlio proprio come ha

47
00:03:26,070 --> 00:03:32,030
fatto attivare un aggiornamento per questo componente e quindi chiamerebbe componente fatto aggiornare a Dnt .

48
00:03:32,270 --> 00:03:36,620
Ora puoi causare effetti collaterali come nel Mt. Non devi aggiornare lo stato qui, perch questo attiver un ri-rendering.

49
00:03:36,830 --> 00:03:41,100
Quindi  fondamentalmente paragonabile al componente montato solo per il caso di aggiornamento.

50
00:03:41,150 --> 00:03:46,520
Ora implementiamo questi hook per vedere quando viene eseguito e come si comporta.

51
00:03:46,520 --> 00:03:52,570
&nbsp;

