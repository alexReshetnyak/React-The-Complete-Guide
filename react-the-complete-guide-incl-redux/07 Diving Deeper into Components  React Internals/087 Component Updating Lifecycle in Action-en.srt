1
00:00:02,320 --> 00:00:08,470
So let's implement these updates related hooks and I won't implement them in all components because

2
00:00:08,470 --> 00:00:11,490
that might let our console log explode

3
00:00:11,590 --> 00:00:12,780
so I'll do it in person.js

4
00:00:12,850 --> 00:00:17,470
component, I'll implement them below the creation related ones

5
00:00:17,530 --> 00:00:23,680
but above render. By the way if you're wondering why I did implement these methods like this and not

6
00:00:23,740 --> 00:00:27,830
as properties with arrow functions, you could absolutely do that

7
00:00:28,000 --> 00:00:34,870
but since these methods are not called through dom events and therefore we will never have this this keyword

8
00:00:35,020 --> 00:00:41,350
issue, we may also use this syntax which you might know from other programming languages too. Back to the

9
00:00:41,350 --> 00:00:42,610
lifecycle hooks though.

10
00:00:42,880 --> 00:00:50,540
Let's start with componentWillReceiveProps and there we get the upcoming props as an argument.

11
00:00:50,770 --> 00:00:56,850
Now in there I'll add a console log statement where I will print update persons.js

12
00:00:56,890 --> 00:00:59,970
so that we can easily see this.

13
00:01:00,400 --> 00:01:10,390
There I'll say inside componentWillReceiveProps and I'll also print nextProps here so that we

14
00:01:10,390 --> 00:01:12,400
can see this.

15
00:01:12,400 --> 00:01:15,940
Let me save this and let's see when this runs. I'll reload the app,

16
00:01:15,940 --> 00:01:20,050
we don't see it here because we defined it in the persons.js file,

17
00:01:20,110 --> 00:01:29,140
if I click toggle persons let's analyze the console.log here we got all the persons related methods,

18
00:01:29,140 --> 00:01:37,660
so persons.js in the constructor, WillMount persons.js render then our single person component,

19
00:01:37,660 --> 00:01:39,910
so these are all single person components

20
00:01:41,160 --> 00:01:45,440
and DidMount, no update related lifestyle hook.

21
00:01:45,440 --> 00:01:48,440
So let me clear the log but it didn't reload the page

22
00:01:48,570 --> 00:01:51,150
and now let's change something,

23
00:01:51,480 --> 00:01:58,680
let's maybe remove one of these persons, Manu here, if I  click on him you'll see render is recalled in

24
00:01:58,720 --> 00:02:01,080
app.js because the state changed

25
00:02:01,290 --> 00:02:07,530
and then we see our update WillReceiveProps is called where we get the updated props where

26
00:02:07,530 --> 00:02:13,980
we have persons which is only two persons now. And then we are inside render of persons and of the two

27
00:02:13,980 --> 00:02:18,390
person components which remained because these needed to re-render,

28
00:02:18,420 --> 00:02:23,030
you saw that the render method is also part of the update lifecycle.

29
00:02:23,520 --> 00:02:24,120
So that's great,

30
00:02:24,120 --> 00:02:25,570
let's add another hook,

31
00:02:25,680 --> 00:02:33,840
a very important method actually, shouldComponentUpdate which is not just a convenience method but

32
00:02:33,840 --> 00:02:40,080
one where we can really save some performance if we cleverly use it. There we get the upcoming props

33
00:02:40,080 --> 00:02:51,940
and state and I will also add a console log here where I will say update persons.js inside

34
00:02:52,570 --> 00:02:59,880
shouldComponentUpdate and I'll print nextProps and nextState here too.

35
00:02:59,890 --> 00:03:04,640
Now as I said this method should return true or false, if it returns true,

36
00:03:04,840 --> 00:03:08,300
the updating continues, if it returns false,

37
00:03:08,320 --> 00:03:10,510
we stop the whole process.

38
00:03:10,510 --> 00:03:13,410
Now let's return false here to see how that would look like,

39
00:03:13,720 --> 00:03:18,680
if I save everything now and I toggle persons, that all works,

40
00:03:18,850 --> 00:03:20,850
but now let's remove Manu again.

41
00:03:21,600 --> 00:03:24,870
I click on him but you see it doesn't update,

42
00:03:24,870 --> 00:03:32,010
you can click on him multiple times, you even see the update method is called, shouldComponentUpdate

43
00:03:32,370 --> 00:03:34,490
and the array there changes,

44
00:03:34,500 --> 00:03:41,280
persons only holds one element here because I did delete two persons, it's not reflected in the dom though

45
00:03:41,610 --> 00:03:47,640
because we cancelled the update process so we never reach the render methods which would be important

46
00:03:47,640 --> 00:03:52,880
for telling react to check if the real dom needs to be updated,

47
00:03:52,890 --> 00:03:55,930
this shows us the power of shouldComponentUpdate.

48
00:03:56,310 --> 00:04:03,870
Now you might wonder why would we ever return false then because here of course it breaks the app

49
00:04:04,070 --> 00:04:07,960
But you might have cases where you know that no update is required,

50
00:04:08,150 --> 00:04:10,020
and of course typically you don't hard code

51
00:04:10,040 --> 00:04:11,590
true or false here

52
00:04:11,700 --> 00:04:17,120
instead you check that based on the upcoming props or state.

53
00:04:17,120 --> 00:04:28,690
So here for example, we know that we only want to continue if nextProps.persons is not equal to this.

54
00:04:28,760 --> 00:04:32,420
props.persons which are the old persons.

55
00:04:32,420 --> 00:04:36,050
Now with this implemented, let's go back, toggle persons,

56
00:04:36,060 --> 00:04:41,890
now if you click on a person, we successfully go through the whole process because the persons array

57
00:04:41,980 --> 00:04:42,840
changed

58
00:04:43,220 --> 00:04:50,390
and by the way this only is true because we used an immutable approach of updating the persons array

59
00:04:50,630 --> 00:04:53,410
because this doesn't deeply check the persons array,

60
00:04:53,510 --> 00:04:59,500
it only sees if it's different objects but these are different objects because of the way we update

61
00:04:59,510 --> 00:05:03,620
persons here in our app.js file. There

62
00:05:03,620 --> 00:05:07,280
when we set persons, we set it to a new array

63
00:05:07,430 --> 00:05:10,570
so it is a totally different object, that's important.

64
00:05:10,640 --> 00:05:14,130
shouldComponentUpdate here doesn't deeply check this,

65
00:05:14,270 --> 00:05:17,150
it only compares the root objects,

66
00:05:17,150 --> 00:05:23,100
the pointers to be precise but these are different because we recreated a new array. But that out of

67
00:05:23,120 --> 00:05:29,330
the way, what would now happen is if we somehow change some other property which might not be relevant

68
00:05:29,330 --> 00:05:31,430
for this component,

69
00:05:31,430 --> 00:05:35,450
this won't trigger an update and we can save performance here.

70
00:05:36,110 --> 00:05:38,170
So this is shouldComponentUpdate,

71
00:05:38,180 --> 00:05:44,120
you don't necessarily need to add it to every component because that would mean you should use stateful

72
00:05:44,120 --> 00:05:49,400
components all over the place and it's kind of against what I said earlier about you using functional

73
00:05:49,400 --> 00:05:51,360
components as often as possible.

74
00:05:51,680 --> 00:05:58,580
But if you have a use case where you know yeah, this component receives a lot of props but actually it

75
00:05:58,580 --> 00:06:02,050
should re-re-render only if one of these props changes,

76
00:06:02,120 --> 00:06:08,810
then you might turn your component into a stateful one and implement shouldComponentUpdate to check

77
00:06:08,960 --> 00:06:14,960
whether this single prop which is important to you did change or not and ignore all the other ones.

78
00:06:15,410 --> 00:06:21,870
So with that, we get this extra check and we can continue implementing lifecycle hooks, the next lifecycle

79
00:06:22,040 --> 00:06:26,000
after shouldComponentUpdate is componentWillUpdate.

80
00:06:26,030 --> 00:06:28,650
Now that we decide that we're about to update, here

81
00:06:28,690 --> 00:06:31,770
I also receive the upcoming state and props,

82
00:06:31,910 --> 00:06:34,930
so now let's log this to the console here too.

83
00:06:35,250 --> 00:06:37,910
Let's log update persons.js

84
00:06:37,970 --> 00:06:51,480
inside componentWillUpdate and log nextProps and nextState here too. With that, let's save this

85
00:06:51,480 --> 00:06:58,990
and let's see it in action one more time, toggle persons, clear the log, delete the person and we see app.js render

86
00:06:59,440 --> 00:07:06,070
componentWillReceiveProps, shouldComponentUpdate will update and then the render methods of the

87
00:07:06,070 --> 00:07:09,100
relevant components, perfect.

88
00:07:09,160 --> 00:07:13,000
Now the next method after componentWillUpdate was render,

89
00:07:13,030 --> 00:07:14,540
we already got that.

90
00:07:14,710 --> 00:07:20,870
The next method thereafter is componentDidUpdate, there

91
00:07:21,020 --> 00:07:31,370
we now can cause side effects just as in componentDidMount and I will quickly print this too.

92
00:07:31,550 --> 00:07:38,130
Here we don't have nextProps and nextState because it's after the update, we just have this.props and this.states

93
00:07:38,360 --> 00:07:44,360
the new props and the new state are the current props and current state at this point of time.

94
00:07:44,540 --> 00:07:50,690
So let's save this one more time, toggle persons, clear the log, delete the person and all the way at the

95
00:07:50,720 --> 00:07:53,540
bottom, you see componentDidUpdate.

96
00:07:53,630 --> 00:07:55,580
So that's the updating lifecycle

97
00:07:55,660 --> 00:08:02,960
if the update is triggered from outside due to change in props, as it is the case for persons, the persons

98
00:08:03,030 --> 00:08:03,920
array changed.

