1
00:00:02,230 --> 00:00:06,540
Now that we optimized our little demo application here,

2
00:00:06,910 --> 00:00:16,120
let me dive into that functional component versus stateful component or container component again.

3
00:00:16,150 --> 00:00:21,670
So basically components defined with class which extend component which is one way of creating a component

4
00:00:21,700 --> 00:00:28,510
and react and components which are just functions as all other components in this application are.

5
00:00:28,960 --> 00:00:36,300
Now as I mentioned a lot in this course, you should try to create functional components as often as possible.

6
00:00:36,360 --> 00:00:37,170
Why?

7
00:00:38,730 --> 00:00:43,860
Because these components have a narrow focus and a clear responsibility,

8
00:00:43,860 --> 00:00:50,610
they are only about presenting something, they are about rendering jsx and they contain some logic to

9
00:00:50,610 --> 00:00:57,850
display the jsx correctly, for example by adding some css classes as we do here in the cockpit component.

10
00:00:57,900 --> 00:00:59,110
They don't do much else

11
00:00:59,130 --> 00:01:03,980
and one thing they definitely don't do and they can't do is manage state.

12
00:01:03,990 --> 00:01:09,630
And I mention a lot that the reason why we have this separation is that we want to have a few places

13
00:01:09,630 --> 00:01:16,230
in our application where the application state does change, this makes sure your application stays maintainable

14
00:01:16,440 --> 00:01:23,550
even as it grows. Because the more your application grows, the harder it becomes to manage state because

15
00:01:23,610 --> 00:01:31,620
if you manage state in every single component, it is super hard to track where you edited this list of

16
00:01:31,620 --> 00:01:35,040
persons, where you created this new post.

17
00:01:35,040 --> 00:01:41,840
If you get a few containers where you do that and where you then simply pass state and hand the rest down via

18
00:01:41,850 --> 00:01:42,860
props

19
00:01:42,870 --> 00:01:48,510
this is much easier to handle because you can always see in the end, the state gets changed here in the

20
00:01:48,510 --> 00:01:49,590
app.js file

21
00:01:49,740 --> 00:01:56,640
And we distribute references to the functions which edited via props but all the other components

22
00:01:56,940 --> 00:02:00,360
are not able to change state.

23
00:02:00,360 --> 00:02:05,530
This is one of the core foundations of a good react application,

24
00:02:05,660 --> 00:02:12,800
use the class based components as little as possible but of course don't be afraid of using them if it

25
00:02:12,800 --> 00:02:14,030
makes sense.

26
00:02:14,210 --> 00:02:20,540
If you get a central point in your application and a good split typically are multiple features,

27
00:02:20,540 --> 00:02:27,200
So for example if you have a blog feature and authentication feature in your app, then the root components

28
00:02:27,310 --> 00:02:34,760
of these features might very well be containers which manage the state for that feature area and you

29
00:02:34,760 --> 00:02:39,650
will see this in action throughout this course when we dive into the bigger course project.

30
00:02:40,160 --> 00:02:47,930
But all other components as mentioned often should be functional components, I'll also dive into one important

31
00:02:47,930 --> 00:02:55,700
difference besides the existence of state and the availability of methods which you have in class based

32
00:02:55,700 --> 00:02:56,270
components.

33
00:02:56,270 --> 00:03:01,460
I'll dive into one other important difference between class components and functional components in the next

34
00:03:01,460 --> 00:03:02,200
lectures

35
00:03:02,390 --> 00:03:07,610
and that would be the lifecycle of a component. Before diving into the lifecycle,

36
00:03:07,820 --> 00:03:14,210
let's compare stateless and stateful components again. Just to bring this back into mind, stateful

37
00:03:14,210 --> 00:03:14,870
components

38
00:03:14,870 --> 00:03:19,380
also referred to as containers and stateless components differ

39
00:03:19,430 --> 00:03:24,620
by the fact that stateful components are created with the class word and extend component whereas

40
00:03:24,620 --> 00:03:29,060
stateless ones are just functions which receive props.

41
00:03:29,120 --> 00:03:32,740
Now import differences are of course the access to state

42
00:03:32,810 --> 00:03:39,950
and does this is new, the existence of lifecycle hooks. In stateful containers, we can access state and we

43
00:03:39,950 --> 00:03:46,640
can implement lifecycle hooks, I'll come back to what that is in the next lecture. Stateless components

44
00:03:46,910 --> 00:03:52,070
neither have access to the state nor can they implement lifecycle hooks,

45
00:03:52,250 --> 00:03:58,260
and if we want to access the state and props, in stateful containers, we do this via the this keyword

46
00:03:58,610 --> 00:04:09,230
this.state.xy, this.props.xy, and in stateless components, we do this via just props.xy, we receive

47
00:04:09,260 --> 00:04:11,290
props as an argument.

48
00:04:11,540 --> 00:04:18,410
And as mentioned often, only use stateful components if you need to manage state or access lifecycle

49
00:04:18,410 --> 00:04:23,860
hooks, use stateless components in all other cases.

50
00:04:23,870 --> 00:04:31,040
And just because we never did it, I want to highlight is this.props.xy thing in stateful components.

51
00:04:31,040 --> 00:04:37,520
If we consider our only stateful component we have here, it doesn't even use props,

52
00:04:37,520 --> 00:04:41,840
it only use state but it would have access to props too

53
00:04:41,960 --> 00:04:44,130
and I can demonstrate this to you.

54
00:04:44,300 --> 00:04:46,840
Let me pass some props right from the index.js

55
00:04:46,880 --> 00:04:47,720
file,

56
00:04:47,870 --> 00:04:58,740
let me pass a title prop here which can just be a string where I will say relevant persons. Now this

57
00:04:58,740 --> 00:05:03,910
can be the title of our application, in app.js which is a container

58
00:05:03,960 --> 00:05:09,540
we can still access props, it's not like it doesn't have access to props. Here,

59
00:05:09,690 --> 00:05:14,290
we want to maybe pass this on to the cockpit to display it there.

60
00:05:14,580 --> 00:05:20,300
So let's define a new title there, a new property there, maybe the app title,

61
00:05:20,310 --> 00:05:23,220
do not confuse it with the prop we're about to pass on.

62
00:05:23,550 --> 00:05:25,880
And now we know that there is this

63
00:05:25,980 --> 00:05:33,530
title property available in our app component because we set it here in the index.js file.

64
00:05:33,540 --> 00:05:36,440
Now of course, we can't access it like this,

65
00:05:36,450 --> 00:05:42,230
we can't access props title because props would be undefined variable here.

66
00:05:42,240 --> 00:05:44,040
We're inside a render method

67
00:05:44,160 --> 00:05:49,620
and inside this method, we never defined props and this method also doesn't receive props as an argument,

68
00:05:49,920 --> 00:05:51,940
so props is undefined here.

69
00:05:52,470 --> 00:05:57,250
But the class itself has a props property because we extend component

70
00:05:57,410 --> 00:06:01,800
And just as we have access to a set state method which we never defined ourselves,

71
00:06:02,010 --> 00:06:05,870
we also have access to a props property we never defined ourselves.

72
00:06:06,090 --> 00:06:13,500
It's given to us and populated by react and we can therefore access this.props like this

73
00:06:13,800 --> 00:06:15,760
and this case, we simply pass it on

74
00:06:15,780 --> 00:06:18,980
but of course we could also output it here in this template.

75
00:06:19,290 --> 00:06:20,950
But since we pass it on,

76
00:06:21,080 --> 00:06:28,050
I'll now go to the cockpit and handle this brand new property maybe here to output it to your props

77
00:06:28,360 --> 00:06:36,440
app title. In here again, just using props because we do receive props as an element here

78
00:06:37,420 --> 00:06:45,160
With one curly brace though. Props is just the argument we receive for this function, passed into it automatically

79
00:06:45,160 --> 00:06:52,630
by react. If we save all files now and go back to our application, you'll see relevant persons as the new title

80
00:06:52,630 --> 00:06:58,380
we're seeing here because now we're setting this in the index.js file and we pass it down

81
00:06:58,420 --> 00:07:02,030
and as you can see, we got props in our container queue,

82
00:07:02,140 --> 00:07:05,720
We didn't use it before because we never received something before

83
00:07:05,800 --> 00:07:12,520
but if you want to use props here, use it with this.props just as you use this.state because you're in

84
00:07:12,520 --> 00:07:13,510
a class here,

85
00:07:13,510 --> 00:07:18,520
You're not in a function, you are not receiving props and state as arguments here.

