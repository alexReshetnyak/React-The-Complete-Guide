1
00:00:02,270 --> 00:00:04,960
Quindi leggi davvero il salvataggio dell'accesso in lettura o scrivi.

2
00:00:05,090 --> 00:00:08,780
Ci permette di risolvere tutti i nostri problemi, no?

3
00:00:08,780 --> 00:00:10,340
Come funziona il relax.

4
00:00:10,640 --> 00:00:16,200
Ricorda bene l'idea di avere un posto centrale dove hai gestito l'intero stato.

5
00:00:16,280 --> 00:00:20,120
Ho detto che non possiamo usare una variabile globale per il debito e non possiamo.

6
00:00:20,450 --> 00:00:28,190
Ma redox ci fornisce un certo flusso di dati in un certo modo di gestire i dati che possiamo poi integrare

7
00:00:28,340 --> 00:00:31,190
piacevolmente con il pacchetto di numeri nel reattore.

8
00:00:31,460 --> 00:00:35,310
In questo modo la reazione reagisce ai cambiamenti di dati.

9
00:00:35,450 --> 00:00:37,480
Ora ti mostreremo come funziona l'integrazione.

10
00:00:37,610 --> 00:00:40,260
Ma prima lasciami descrivere le sue opere di redux.

11
00:00:40,310 --> 00:00:44,720
Come gestisce i dati e come viene aggiornato alla fine.

12
00:00:44,720 --> 00:00:49,440
Si tratta di un negozio centrale che abbiamo in ogni applicazione redox.

13
00:00:49,670 --> 00:00:56,280
E voglio sottolineare che redox  una libreria di terze parti che erano atti totalmente indipendenti dalla reazione.

14
00:00:56,330 --> 00:01:02,160
Viene visto pi spesso in combinazione con la reazione, ma in teoria  indipendente.

15
00:01:02,450 --> 00:01:04,310
Quindi  tutto un negozio centrale.

16
00:01:04,310 --> 00:01:07,370
Questo negozio memorizza l'intero stato dell'applicazione.

17
00:01:07,370 --> 00:01:08,290
 cos semplice.

18
00:01:08,330 --> 00:01:12,800
Puoi pensarci come un gigantesco oggetto javascript.

19
00:01:13,070 --> 00:01:18,860
Ora in un'applicazione re-act e di nuovo in lettura, X  indipendente dalla reazione, ma  il caso d'uso pi comune

20
00:01:18,860 --> 00:01:21,350
ed  un corso di re-act qui alla fine.

21
00:01:21,530 --> 00:01:29,630
Abbiamo componenti e un componente probabilmente vuole manipolare o ottenere lo stato dell'applicazione dickered.

22
00:01:29,630 --> 00:01:34,990
Ora non lo fa manipolando direttamente quell'oggetto javascript centrale.

23
00:01:35,090 --> 00:01:42,320
sistema di reattivit reattivo e, ancor peggio, renderebbe il nostro negozio abbastanza imprevedibile se venissero modificati da qualsiasi punto

24
00:01:42,380 --> 00:01:50,450
della nostra applicazione che non potremmo mai vedere dove abbiamo apportato un certo cambiamento che ha rotto la nostra app, ad esempio.

25
00:01:50,450 --> 00:01:52,790
Ci non verrebbe rilevato da un

26
00:01:52,790 --> 00:01:59,180
Quindi abbiamo un processo prevedibile e chiaro di aggiornamento dello stato su cui possiamo fare affidamento e che

27
00:01:59,180 --> 00:02:02,210
 l'unico processo che pu cambiare il nostro stato.

28
00:02:02,510 --> 00:02:09,310
Questo  in realt ci che Rydex fa per avere un processo chiaramente definito su come il tuo stato pu cambiare.

29
00:02:09,650 --> 00:02:16,430
Il primo elemento di base oltre al negozio centrale sono azioni che vengono inviate dal codice

30
00:02:16,430 --> 00:02:23,540
javascript in un reattore che vengono inviate dai componenti e l'azione  solo un pacchetto di informazioni

31
00:02:23,540 --> 00:02:28,740
e si termina con un tipo di ingrediente aggiunto o rimozione di ingrediente.

32
00:02:28,790 --> 00:02:31,960
Quindi una descrizione che potresti dire possibilmente.

33
00:02:32,060 --> 00:02:33,950
Tiene anche un carico utile.

34
00:02:33,950 --> 00:02:41,360
Ad esempio, se l'azione  un ingrediente, abbiamo bisogno di tutte le informazioni passate su quale ingrediente e che

35
00:02:41,360 --> 00:02:43,360
sarebbe anche una parte dell'azione.

36
00:02:43,370 --> 00:02:49,070
Quindi  un pacchetto di informazioni che stiamo inviando al mondo o per leggere X per essere precisi.

37
00:02:49,580 --> 00:02:52,730
Quell'azione non ha raggiunto direttamente un negozio.

38
00:02:52,760 --> 00:02:57,290
Quell'azione non ha alcuna logica che non sappia come far funzionare il negozio.

39
00:02:57,290 --> 00:03:00,240
 solo una cosa da messaggero.

40
00:03:00,290 --> 00:03:03,160
Cambiare il negozio  un riduttore.

41
00:03:03,170 --> 00:03:09,010
Ora qui ho scritto riduttori perch in realt possiamo combinare pi riduttori in uno.

42
00:03:09,230 --> 00:03:14,590
Ma alla fine ti ritroverai con un riduttore di percorso che  collegato direttamente al tuo negozio

43
00:03:14,590 --> 00:03:15,160
alla fine.

44
00:03:15,170 --> 00:03:21,440
Quindi l'azione raggiunge il produttore e poich l'azione contiene un tipo il riduttore pu controllare il

45
00:03:21,440 --> 00:03:22,420
tipo di azione.

46
00:03:22,430 --> 00:03:30,600
Ad esempio se si tratta di un ingrediente e non abbiamo trovato un codice per il tipo di azione dati

47
00:03:30,740 --> 00:03:39,020
nel riduttore, il riduttore alla fine  solo una funzione pura che riceve l'azione e il vecchio stato come input

48
00:03:39,020 --> 00:03:42,340
e che quindi sputa uno stato aggiornato .

49
00:03:42,350 --> 00:03:50,210
La cosa importante  che il produttore deve eseguire solo codice sincrono senza codice asincrono senza effetti

50
00:03:50,210 --> 00:03:53,650
collaterali nessun HTP non richiede nulla di ci.

51
00:03:53,720 --> 00:03:59,970
In seguito imparerai come  possibile implementare il codice asincrono, ma nei riduttori  solo un input e

52
00:04:00,110 --> 00:04:02,020
non emette alcun risultato intermedio.

53
00:04:02,150 --> 00:04:03,320
Nessun ritardo.

54
00:04:03,770 --> 00:04:09,890
Quindi questo  il loro douceur e i riduttori inseriscono lo stato aggiornato che viene quindi archiviato nuovamente

55
00:04:09,890 --> 00:04:12,050
nel negozio e sostituisce il vecchio stato.

56
00:04:12,050 --> 00:04:15,120
E questo deve essere fatto in modo immutabile.

57
00:04:15,170 --> 00:04:20,930
Quindi restituiamo sempre un nuovo stato che pu essere basato su quello vecchio ma che tecnicamente 

58
00:04:20,960 --> 00:04:26,840
un nuovo oggetto javascript perch gli oggetti sono tipi di riferimento e Javascript e vogliamo assicurarci di non

59
00:04:26,840 --> 00:04:28,280
modificare accidentalmente quello vecchio.

60
00:04:28,520 --> 00:04:31,890
Ecco come il riduttore gestisce l'azione.

61
00:04:31,910 --> 00:04:33,800
Ora il negozio  aggiornato.

62
00:04:33,830 --> 00:04:40,610
Come riportare lo stato aggiornato nel nostro componente, per questo utilizziamo la distorsione del modello di abbonamento

63
00:04:41,270 --> 00:04:48,920
che attiva tutte le sottoscrizioni ogni volta che lo stato cambia ogni volta che uno stato viene aggiornato nell'archivio.

64
00:04:49,190 --> 00:04:56,340
E ovviamente il nostro componente pu iscriversi agli aggiornamenti del negozio e quindi riceve automaticamente quell'aggiornamento.

65
00:04:56,360 --> 00:04:57,630
 cos semplice.

66
00:04:57,650 --> 00:05:03,450
Funziona attraverso un modello di abbonamento e dovremmo semplicemente dire pay che voglio ricevere una notifica ogni volta che lo

67
00:05:03,450 --> 00:05:04,130
stato cambia.

68
00:05:04,260 --> 00:05:06,830
Proprio come diciamo hey voglio cambiare lo stato.

69
00:05:06,840 --> 00:05:09,390
Ecco un'azione che descrive i miei piani.

70
00:05:09,410 --> 00:05:10,680
Il flusso del redux.

71
00:05:10,730 --> 00:05:12,060
Questo ha opere di redux.

72
00:05:12,060 --> 00:05:15,650
Pochissimi radicali per lo vediamo in azione sul prossimo Electra.

