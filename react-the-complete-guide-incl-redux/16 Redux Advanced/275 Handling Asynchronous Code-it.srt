1
00:00:02,240 --> 00:00:07,110
Nell'ultimo video introduciamo alcuni creatori di azioni sincrone.

2
00:00:07,310 --> 00:00:13,670
Ora vogliamo approfittarne per gestire il codice asincrono e per gestire il codice asincrono, abbiamo bisogno di aggiungere

3
00:00:13,670 --> 00:00:16,660
uno speciale middleware al nostro progetto di redux.

4
00:00:16,730 --> 00:00:24,130
Una libreria di terze parti che possiamo aggiungere chiamata redux phunk qui sono nella pagina Get up semplicemente google per

5
00:00:24,140 --> 00:00:29,630
il redox funk Ripp come questo per trovarlo qui puoi trovare pi istruzioni su questo.

6
00:00:29,630 --> 00:00:36,740
Generalmente si tratta di una libreria che, come ho appena detto, aggiunge un middleware al

7
00:00:36,740 --> 00:00:45,740
tuo progetto che consente alle tue azioni di non specificare esattamente dove i tuoi creatori effettivi restituiscono l'azione stessa,

8
00:00:45,740 --> 00:00:52,460
ma restituiscono una funzione che alla fine invier un'azione con questo piccolo trucco.

9
00:00:52,550 --> 00:00:57,390
Nadra che agita l'azione stessa, ma una funzione che quindi ne invier una.

10
00:00:57,410 --> 00:01:05,910
Possiamo eseguire codice asincrono perch alla fine inviamo una parte  la parte che pu essere eseguita in modo asincrono.

11
00:01:05,900 --> 00:01:08,500
Diventer pi chiaro una volta aggiunto.

12
00:01:08,570 --> 00:01:15,160
Quindi, per aggiungerlo, facciamo una pausa o abbandoniamo l'avvio di NPM e installiamo un nuovo pacchetto

13
00:01:15,170 --> 00:01:21,460
con il dash dash installato in NPM, salvando il nome come scritto in questo modo.

14
00:01:21,530 --> 00:01:24,410
Ora con questo verr scaricato e memorizzato.

15
00:01:24,440 --> 00:01:29,800
Come sempre, possiamo quindi registrarlo come un middleware per il nostro progetto.

16
00:01:29,810 --> 00:01:33,580
 sempre possibile trovare istruzioni dettagliate e ovviamente riceviamo una pagina.

17
00:01:33,590 --> 00:01:34,670
L lo vedi.

18
00:01:34,670 --> 00:01:39,790
Dopo averlo installato alla fine, abbiamo aggiunto il middleware Apply.

19
00:01:40,130 --> 00:01:47,330
Quindi torniamo al nostro indice di caduta dei chip in cui creiamo il negozio e aggiungiamo il middleware

20
00:01:47,330 --> 00:01:49,880
e ora stiamo importando questo nuovo pacchetto.

21
00:01:50,020 --> 00:01:59,010
Quindi importa qualcosa dalla funzione redox e che qualcosa pu essere trovato sulla loro pagina.

22
00:01:59,030 --> 00:02:01,710
In realt hanno un'esportazione predefinita e noi no.

23
00:02:01,740 --> 00:02:05,180
Altrettanto robusti possiamo dargli un nome che vogliamo.

24
00:02:05,180 --> 00:02:08,420
Mi limiter a phunk ma puoi ribattezzarlo con quello che vuoi.

25
00:02:08,540 --> 00:02:11,490
Questo pacchetto essenzialmente sfrutta solo il middleware.

26
00:02:11,660 --> 00:02:13,250
Ora questo  gi un middleware.

27
00:02:13,280 --> 00:02:19,550
Quindi dietro le quinte sembra la nostra abitudine con la parola coppia di chiamate di funzioni annidate

28
00:02:19,550 --> 00:02:21,530
e quindi possiamo aggiungerla ora qui.

29
00:02:21,560 --> 00:02:22,720
Ora applica il middleware.

30
00:02:22,810 --> 00:02:23,670
Lo aggiunger

31
00:02:23,780 --> 00:02:30,520
Dopo una lunga melodia Cos un oggetto abbiamo appena importato quella funzione per essere precisi.

32
00:02:30,680 --> 00:02:36,260
vogliamo eseguire il timeout dei set e solo dopo 2 secondi vogliamo memorizzare il risultato.

33
00:02:36,440 --> 00:02:44,780
Quindi questa volta con l'aggiunta di questo, possiamo tornare ai nostri effettivi autori e alla caduta effettiva di SJS e diciamo

34
00:02:44,810 --> 00:02:47,660
nel risultato di negozio che in realt

35
00:02:47,660 --> 00:02:56,000
Quindi qui in questa funzione che viene eseguita in qualche modo l dentro, vogliamo restituire questa azione dopo due secondi per

36
00:02:56,000 --> 00:03:03,230
simulare che prima o prima questa azione  stata raggiunta da un server per memorizzarla l e aggiornare

37
00:03:03,320 --> 00:03:10,160
solo il nostro stato una volta che questo ha avuto successo per esempio ora con pap con

38
00:03:10,160 --> 00:03:11,710
l'attuale configurazione qui non funzioner.

39
00:03:12,040 --> 00:03:19,460
Ma con il middleware phunk aggiungilo cosa possiamo fare  che possiamo cambiare la dichiarazione return qui e la metter

40
00:03:19,460 --> 00:03:23,560
davanti a quel momento modellabile pulir il resto qui a breve.

41
00:03:23,810 --> 00:03:29,480
Quindi aggiunger una nuova dichiarazione di ritorno che restituir una funzione che  importante.

42
00:03:29,480 --> 00:03:31,910
Ora puoi usare nuovamente la parola chiave function.

43
00:03:31,910 --> 00:03:36,980
Questa funzione riceve la spedizione come argomento per l'invio di un'azione.

44
00:03:36,980 --> 00:03:39,000
Ora riceviamo la spedizione qui.

45
00:03:39,190 --> 00:03:47,510
A causa della funzione redux ho detto che il middleware corre tra l'invio di un'azione e il punto temporale in

46
00:03:47,510 --> 00:03:49,800
cui l'azione raggiunge il produttore.

47
00:03:50,120 --> 00:03:56,150
Ora, la cosa che facciamo qui  che inviamo ancora un'azione, ma poi il messaggio di Rydex sul

48
00:03:56,300 --> 00:03:59,470
middleware  entrato nei passaggi ha accesso all'azione l.

49
00:03:59,720 --> 00:04:06,530
In pratica blocca la vecchia azione che potremmo dire e la invia nuovamente in futuro.

50
00:04:06,530 --> 00:04:13,790
Ora la nuova X arriver al produttore, ma in-between redux func  in grado di aspettare perch pu

51
00:04:13,790 --> 00:04:15,890
inviare un'azione qualsiasi cosa voglia.

52
00:04:15,890 --> 00:04:21,860
Questa  la parte asincrona e ci sta esattamente permettendo di eseguire un codice asincrono all'interno

53
00:04:21,860 --> 00:04:22,930
di questa funzione.

54
00:04:22,980 --> 00:04:29,360
E ovviamente possiamo usare anche la buona vecchia sintassi dell'ERX di ESX come questa.

55
00:04:29,570 --> 00:04:36,850
Quindi il codice all'interno di questa funzione di invio qui viene eseguito e ora all'interno del timeout impostato.

56
00:04:36,890 --> 00:04:45,500
passata per impostare il timeout, possiamo eseguire questa patch per inviare ora qualsiasi azione vogliamo spedire.

57
00:04:45,650 --> 00:04:47,480
All'interno di questa funzione

58
00:04:47,480 --> 00:04:55,090
Ora ovviamente tratteremo un ciclo infinito se inviamo di nuovo il risultato del negozio qui o il creatore dell'azione.

59
00:04:55,550 --> 00:05:02,030
Quindi, cosa facciamo in genere, creiamo creatori di azioni asincrone che l'India invia azioni

60
00:05:02,030 --> 00:05:03,680
create da quelle sincrone.

61
00:05:03,680 --> 00:05:10,180
Quindi quello che far  creare rapidamente un nuovo creatore di ection ed esportarlo o rivendicarlo salvando il risultato.

62
00:05:10,210 --> 00:05:17,420
Questo sar ancora il creatore dell'azione come lo avevamo prima di ricevere il risultato e stanno restituendo

63
00:05:17,780 --> 00:05:21,780
l'azione che usiamo in precedenza con il tipo store result.

64
00:05:23,220 --> 00:05:28,740
Pap  il mio sincronizzatore d'azione Creatore in negozio.

65
00:05:28,750 --> 00:05:37,440
Comunque ora spedir esattamente quel creatore di azioni di assalto Savery che mi restituisce questa azione che aggiorna effettivamente

66
00:05:37,530 --> 00:05:42,960
lo stato e lo store perch  l'azione del tipo che gestiamo

67
00:05:42,960 --> 00:05:43,990
nel riduttore.

68
00:05:44,040 --> 00:05:47,370
Ora, prima di vedere quello in azione che dovrebbe rendere pi chiaro il flusso.

69
00:05:47,640 --> 00:05:53,580
C' una cosa che dobbiamo tenere a mente qui assalto non censurato quando restituiamo questa funzione che verr eseguita

70
00:05:53,580 --> 00:05:59,310
da Redux Funk e dove abbiamo impostato il timeout in cui il dentista ha patchato l'azione che dovrebbe

71
00:05:59,310 --> 00:06:01,940
essere eseguita in modo sincrono e aggiornare la storia.

72
00:06:02,190 --> 00:06:09,130
di eseguire l'assalto di Savery che  questo creatore di azioni come una funzione, naturalmente, e lasciarsi andare.

73
00:06:09,150 --> 00:06:09,780
Abbiamo bisogno

74
00:06:09,780 --> 00:06:13,480
Quindi non ripetere il carico utile al negozio con morti.

75
00:06:13,500 --> 00:06:20,910
Assicurati di salvare tutte le cadute, incluso il contatore, e poi riavvia NPM per vedere

76
00:06:20,910 --> 00:06:21,790
se funziona.

77
00:06:21,840 --> 00:06:31,190
E per vedere anche il flusso degli eventi nei nostri strumenti di redox dev in modo che l'app caricata possa ancora manipolare il

78
00:06:31,190 --> 00:06:34,780
nostro negozio di liquori di controcorrente o assaltare qui.

79
00:06:35,000 --> 00:06:40,760
Vedete che ci sono voluti due secondi per stampare effettivamente i risultati del negozio.

80
00:06:40,880 --> 00:06:42,250
Questa  la cosa interessante

81
00:06:42,320 --> 00:06:44,840
Non hai mai visto questo altro creatore di ection.

82
00:06:44,840 --> 00:06:48,350
Dobbiamo dedicare del tempo al suo interno per portare a qualsiasi output.

83
00:06:48,480 --> 00:06:54,010
Il risultato del negozio di fatti non accade immediatamente dopo solo due secondi dal risultato del negozio in C.

84
00:06:54,210 --> 00:07:00,830
Quindi solo l'azione spedita l dentro dopo due secondi lascia un'impronta perch  la nostra azione

85
00:07:00,830 --> 00:07:08,900
sincrona e solo le azioni sincrone possono essere aggiunte per memorizzare altri creatori di azioni come il risultato del

86
00:07:08,930 --> 00:07:11,630
negozio che esegue un codice asincrono.

87
00:07:11,780 --> 00:07:16,410
La nostra unica funzione possibile di youtoo redux e sono presi in mezzo.

88
00:07:16,670 --> 00:07:18,760
Non arrivano mai al riduttore.

89
00:07:18,800 --> 00:07:27,050
Li usiamo solo come un utile passaggio intermedio per eseguire il nostro codice asincrono che  necessario

90
00:07:27,050 --> 00:07:33,860
eseguire su molte azioni e quindi inviare un'azione sincrona per cambiare lo stato nell'archivio.

91
00:07:33,860 --> 00:07:36,150
Una volta che siamo certi di sapere cosa fare l.

92
00:07:36,170 --> 00:07:41,780
Quindi, una volta che il nostro codice asincrono  finito, questo  il motivo per

93
00:07:42,190 --> 00:07:49,160
cui lo vediamo qui nella console abbastanza interessante in cui abbiamo il nostro middleware del logger chiaro che vedrai

94
00:07:49,280 --> 00:07:56,630
che otteniamo pi output perch pi a lungo registra tutto ci che raggiunge la canalizzazione dell'azione e che include il

95
00:07:56,630 --> 00:08:03,820
nostro funzione che viene restituita dall'azione asincrona non abbiamo mai aggiunto questo stato qui, perch viene bloccato dalla funzione redux.

96
00:08:03,890 --> 00:08:11,890
Ecco come possiamo lavorare con i creatori di azioni per gestire codice asincrono nel nostro negozio redux.

