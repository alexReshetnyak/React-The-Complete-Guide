1
00:00:02,070 --> 00:00:05,790
Preact jest wic wietny, jest mniejszy i ma prawie ten

2
00:00:05,790 --> 00:00:11,220
sam interfejs API, wic zawsze powinnimy go uywa. Odpowied jak zwykle zaley od tego, dowiedzmy

3
00:00:11,220 --> 00:00:13,110
si, jakie s rnice, po

4
00:00:13,290 --> 00:00:17,810
prostu znajdmy to na preactjs. com, aby klikn na przewodniku,

5
00:00:18,000 --> 00:00:21,520
moesz take klikn rnice, aby tam zareagowa.

6
00:00:21,540 --> 00:00:25,360
Teraz moesz przeczyta ten artyku, aby dowiedzie si wicej o rnicach.

7
00:00:25,620 --> 00:00:27,390
W kocu masz tu

8
00:00:27,450 --> 00:00:29,060
adn list, widzisz, co

9
00:00:29,070 --> 00:00:31,850
zawiera, wic to, co dokadnie reaguje.

10
00:00:31,890 --> 00:00:37,440
I to s rzeczy takie jak komponenty wyszego rzdu, tworzenie komponentw, twoje funkcjonalne

11
00:00:37,440 --> 00:00:38,940
komponenty i wszystko inne,

12
00:00:38,970 --> 00:00:45,920
zobaczysz rwnie, e na przykad reaguj element create staje si h (), funkcj zwan h ().

13
00:00:46,020 --> 00:00:51,240
Jest to jedna z niewielkich rnic, o ktrych wspomniaem, to prawie ten sam interfejs API, ale nie

14
00:00:51,240 --> 00:00:53,650
cakiem, ale ta strona zawiera list wszystkich rnic.

15
00:00:53,940 --> 00:00:58,410
Wic, co zostao dodane, jak powiedziaem, oferuje nawet kilka nowych funkcji

16
00:00:58,500 --> 00:01:04,190
i na przykad, dostajesz to. rekwizyty i to. Stan przekazany jako argument funkcji

17
00:01:04,320 --> 00:01:09,740
renderowania, dziki czemu mona tam po prostu wywoywa rekwizyty i stany bez tego sowa

18
00:01:09,750 --> 00:01:15,070
kluczowego, ale nadal mona uywa tego sowa kluczowego, o czym rwnie wspomina si tutaj.

19
00:01:15,090 --> 00:01:18,880
To fajny dodatek i to oglnie temat

20
00:01:18,900 --> 00:01:19,400
dodanych

21
00:01:19,410 --> 00:01:20,700
rzeczy, miych dodatkw.

22
00:01:20,700 --> 00:01:26,250
Na przykad moesz uy sowa kluczowego class i nie musisz uywa nazwy klasy,

23
00:01:26,250 --> 00:01:29,630
poniewa reagujesz, wszystkie te mae rzeczy zostay dodane.

24
00:01:29,910 --> 00:01:32,050
Ale oczywicie brakuje te rzeczy,

25
00:01:32,160 --> 00:01:35,670
na przykad walidacji typu prop, chocia typy rekwizytw

26
00:01:35,670 --> 00:01:41,480
rwnie zostay wcignite do osobnej biblioteki z najnowsz wersj reagowania, aby by szczerym.

27
00:01:41,490 --> 00:01:45,410
Tak wic brakujca cz nie jest tutaj tak istotna, wikszo

28
00:01:45,460 --> 00:01:50,450
rzeczy, ktrych brakuje, to rzeczy za kulisami. W rzeczywistoci s to gwnie kosmetyczne

29
00:01:50,460 --> 00:01:55,710
rzeczy, ale take cakiem sporo kodu rdowego, co z pewnoci jest czym

30
00:01:55,770 --> 00:02:02,370
do rozwaenia i moemy sobie wyobrazi, e typy rekwizytw zostay umieszczone w osobnej bibliotece przez

31
00:02:02,370 --> 00:02:10,430
zesp reagujcy, aby zmniejszy rozmiar reagowania. biblioteka i podejd bliej. To rnice na ekranie tutaj, na stronie i ten

32
00:02:10,470 --> 00:02:18,060
artyku powinien by pomocny dla ciebie, jeli sprbujesz przeczy si z API reakcji na preact, poniewa

33
00:02:18,060 --> 00:02:20,950
wspomniaem, e to prawie to samo,

34
00:02:21,030 --> 00:02:22,910
to mae rzeczy, takie

35
00:02:22,920 --> 00:02:26,950
jak h ( ) zamiast reagowa na element create,

36
00:02:27,120 --> 00:02:31,260
ale prawdopodobnie nigdy nie zadzwonie, aby rcznie reagowa na

37
00:02:31,410 --> 00:02:34,920
tworzenie elementu, a jsx oczywicie jest obsugiwany.

38
00:02:35,070 --> 00:02:40,450
Najwiksz rnic, jaka kryje si za kulisami, jest prawdopodobnie to, jak dziaa dyfuzja

39
00:02:40,470 --> 00:02:46,110
domowa, wic jak preact dowiaduje si, czy musi co zaktualizowa, i jak reaguje.

40
00:02:46,340 --> 00:02:54,290
I potrzebujemy benchmarku, aby dowiedzie si, co jest lepsze, jeli chcemy mierzy go w coraz lepszych kategoriach.

41
00:02:54,660 --> 00:03:00,090
Aby odpowiedzie na to pytanie, co jest lepsze, moesz wyszuka benchmark ram

42
00:03:00,090 --> 00:03:06,210
javascript i powiniene znale to repozytorium github, tam kilka rnych struktur javascriptowych porwnuje si

43
00:03:06,210 --> 00:03:07,280
ze sob,

44
00:03:07,380 --> 00:03:09,730
moesz rwnie pobra i uruchomi

45
00:03:09,740 --> 00:03:15,210
na swoim komputerze Ostrzegam Ci, e zajmuje to sporo czasu, ale wygodnie,

46
00:03:15,210 --> 00:03:17,890
moesz znale najnowsze wyniki tych benchmarkw

47
00:03:17,940 --> 00:03:24,690
w repozytorium github, jeli klikniesz to zdjcie tutaj. Nastpnie dostajesz ten st, ktry jest do duy, gdzie

48
00:03:24,690 --> 00:03:28,000
moesz zobaczy wiele rnych ram javascriptowych porwnanych ze sob,

49
00:03:28,170 --> 00:03:34,050
zawsze powiniene by ostrony przy analizowaniu takich liczb, poniewa testy tutaj mog nie by wane dla

50
00:03:34,050 --> 00:03:35,800
rodzaju aplikacji, ktr masz budynek.

51
00:03:35,910 --> 00:03:42,090
W kocu testujemy tutaj kilka operacji, jak na przykad tworzenie i usuwanie

52
00:03:42,090 --> 00:03:43,650
10000 wierszy danych

53
00:03:43,650 --> 00:03:47,100
i tam moemy znale reakcj 16, wic

54
00:03:47,220 --> 00:03:53,370
najnowsza wersja reakcji, ktrej uyem do nagrywania tego kursu, znajdujemy tutaj rwnie .

55
00:03:53,550 --> 00:04:02,370
Teraz, gdy je porwnamy, widzimy, e s one bardzo zblione pod wzgldem wydajnoci, ale moemy rwnie zobaczy

56
00:04:02,370 --> 00:04:12,060
na przykad, e dla czasu startowego, ktry jest tutaj drugim najniszym rzdem, wersja 16 reagowania ma 53 milisekundy, a

57
00:04:12,130 --> 00:04:16,350
preact ma 36, co jest do troch szybciej.

58
00:04:16,350 --> 00:04:19,860
Powodem tego jest oczywicie mniejszy rozmiar, widzimy

59
00:04:20,190 --> 00:04:27,450
te, e pomimo mniejszego rozmiaru, dla operacji takich jak czyszczenie wielu wierszy, trzeci rzd

60
00:04:27,450 --> 00:04:35,140
od dou, reagowanie jest szybsze ni preact, poniewa rozmiar pliku biblioteki nie robi ".

61
00:04:35,250 --> 00:04:41,360
Na tym zaley, jak efektywny jest algorytm rnicujcy i algorytm aktualizacji.

62
00:04:41,400 --> 00:04:48,840
I oczywicie preact musi rozebra pewne rzeczy, reakcja z drugiej strony wydaje si by nieco bardziej efektywna, kiedy

63
00:04:48,840 --> 00:04:50,740
patrzymy na ten benchmark.

64
00:04:51,090 --> 00:04:52,860
Tak wic moesz na

65
00:04:52,900 --> 00:04:58,770
to spojrze, preact oszczdza ci mnstwo czasu, gdy adujesz aplikacj, kiedy uruchamiasz j po

66
00:04:58,770 --> 00:04:59,360
raz

67
00:04:59,370 --> 00:05:05,840
pierwszy, jest znacznie mniejsza, nie zajmuje tak duo miejsca i jeli masz Aplikacja, w ktrej

68
00:05:05,840 --> 00:05:13,400
pocztkowy czas pobierania ma due znaczenie i gdzie chcesz przesa jak najmniejszy kod za porednictwem kabla, preact moe

69
00:05:13,430 --> 00:05:15,150
by wietn alternatyw do reagowania.

70
00:05:15,410 --> 00:05:23,600
Jeli budujesz super du, wydajn aplikacj dla przedsibiorstw, reakcja szczeglnie w wersji 16 moe

71
00:05:23,900 --> 00:05:26,010
by lepszym wyborem.

72
00:05:26,360 --> 00:05:32,780
Niezalenie od tego, co wybierzesz, moesz zagra z preact, przeczytaj przewodnik, aby dowiedzie

73
00:05:32,780 --> 00:05:33,690
si, jak

74
00:05:33,740 --> 00:05:41,990
z niego skorzysta, uyj preact-cli, aby atwo tworzy nowe projekty i bd wiadomy, e istnieje wspaniaa alternatywa

75
00:05:41,990 --> 00:05:46,970
do reagowania jest zasadniczo taki sam, ale znacznie mniejszy, gdy

76
00:05:46,970 --> 00:05:48,800
patrzymy na rozmiar biblioteki.

